// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../@gamestdio/state-listener
//   ../@colyseus/schema
//   ../@gamestdio/websocket

declare module 'Colyseus' {
    import './legacy';
    export { Client, JoinOptions } from 'Colyseus/Client';
    export { Protocol } from 'Colyseus/Protocol';
    export { Room } from 'Colyseus/Room';
    export { DataChange } from '@gamestdio/state-listener';
    export { Auth, Platform, Device } from "Colyseus/Auth";
    import { FossilDeltaSerializer } from 'Colyseus/serializer/FossilDeltaSerializer';
    import { SchemaSerializer } from "Colyseus/serializer/SchemaSerializer";
    import { registerSerializer } from 'Colyseus/serializer/Serializer';
    export { Schema, type } from "@colyseus/schema";
    export { registerSerializer, FossilDeltaSerializer, SchemaSerializer };
}

declare module 'Colyseus/Client' {
    import { Room, RoomAvailable } from 'Colyseus/Room';
    import { Auth } from 'Colyseus/Auth';
    import { Push } from 'Colyseus/Push';
    import { RootSchemaConstructor } from 'Colyseus/serializer/SchemaSerializer';
    export type JoinOptions = any;
    export class MatchMakeError extends Error {
        code: number;
        constructor(message: string, code: number);
    }
    export class Client {
        auth: Auth;
        push: Push;
        protected endpoint: string;
        constructor(endpoint: string);
        joinOrCreate<T>(roomName: string, options?: JoinOptions, rootSchema?: RootSchemaConstructor): Promise<Room<T>>;
        create<T>(roomName: string, options?: JoinOptions, rootSchema?: RootSchemaConstructor): Promise<Room<T>>;
        join<T>(roomName: string, options?: JoinOptions, rootSchema?: RootSchemaConstructor): Promise<Room<T>>;
        joinById<T>(roomId: string, options?: JoinOptions, rootSchema?: RootSchemaConstructor): Promise<Room<T>>;
        reconnect<T>(roomId: string, sessionId: string, rootSchema?: RootSchemaConstructor): Promise<Room<T>>;
        getAvailableRooms(roomName?: string): Promise<RoomAvailable[]>;
        protected createMatchMakeRequest<T>(method: string, roomName: string, options?: JoinOptions, rootSchema?: RootSchemaConstructor): Promise<Room<T>>;
        protected createRoom<T>(roomName: string, rootSchema?: RootSchemaConstructor): Room<T>;
        protected buildEndpoint(room: any, options?: any): string;
    }
}

declare module 'Colyseus/Protocol' {
    export enum Protocol {
        USER_ID = 1,
        JOIN_REQUEST = 9,
        JOIN_ROOM = 10,
        JOIN_ERROR = 11,
        LEAVE_ROOM = 12,
        ROOM_DATA = 13,
        ROOM_STATE = 14,
        ROOM_STATE_PATCH = 15,
        ROOM_LIST = 20,
        BAD_REQUEST = 50
    }
    export function utf8Read(view: DataView, offset: number): string;
    export function utf8Length(str?: string): number;
}

declare module 'Colyseus/Room' {
    import { Connection } from 'Colyseus/Connection';
    import { Serializer } from 'Colyseus/serializer/Serializer';
    import { Protocol } from 'Colyseus/Protocol';
    import { Listener } from '@gamestdio/state-listener';
    import { RootSchemaConstructor } from 'Colyseus/serializer/SchemaSerializer';
    export interface RoomAvailable {
        roomId: string;
        clients: number;
        maxClients: number;
        metadata?: any;
    }
    export class Room<State = any> {
        id: string;
        sessionId: string;
        name: string;
        onJoin: {
            (this: any, cb: (...args: any[]) => void): import("strong-events/lib").EventEmitter<(...args: any[]) => void>;
            once(cb: (...args: any[]) => void): void;
            remove(cb: (...args: any[]) => void): void;
            invoke(...args: any[]): void;
            clear(): void;
        };
        onStateChange: {
            (this: any, cb: (state: State) => void): import("strong-events/lib").EventEmitter<(state: State) => void>;
            once(cb: (state: State) => void): void;
            remove(cb: (state: State) => void): void;
            invoke(state: State): void;
            clear(): void;
        };
        onMessage: {
            (this: any, cb: (data: any) => void): import("strong-events/lib").EventEmitter<(data: any) => void>;
            once(cb: (data: any) => void): void;
            remove(cb: (data: any) => void): void;
            invoke(data: any): void;
            clear(): void;
        };
        onError: {
            (this: any, cb: (message: string) => void): import("strong-events/lib").EventEmitter<(message: string) => void>;
            once(cb: (message: string) => void): void;
            remove(cb: (message: string) => void): void;
            invoke(message: string): void;
            clear(): void;
        };
        onLeave: {
            (this: any, cb: (code: number) => void): import("strong-events/lib").EventEmitter<(code: number) => void>;
            once(cb: (code: number) => void): void;
            remove(cb: (code: number) => void): void;
            invoke(code: number): void;
            clear(): void;
        };
        connection: Connection;
        serializerId: string;
        protected serializer: Serializer<State>;
        protected previousCode: Protocol;
        protected rootSchema: RootSchemaConstructor;
        constructor(name: string, rootSchema?: RootSchemaConstructor);
        connect(endpoint: string): void;
        leave(consented?: boolean): void;
        send(data: any): void;
        readonly state: State;
        readonly hasJoined: boolean;
        listen(segments: string, callback: Function, immediate?: boolean): Listener;
        removeListener(listener: Listener): void;
        removeAllListeners(): void;
        protected onMessageCallback(event: MessageEvent): void;
        protected setState(encodedState: any): void;
        protected patch(binaryPatch: any): void;
    }
}

declare module 'Colyseus/Auth' {
    export enum Platform {
        ios = "ios",
        android = "android"
    }
    export interface Device {
        id: string;
        platform: Platform;
    }
    export interface IStatus {
        status: boolean;
    }
    export interface IUser {
        _id: string;
        username: string;
        displayName: string;
        avatarUrl: string;
        isAnonymous: boolean;
        email: string;
        lang: string;
        location: string;
        timezone: string;
        metadata: any;
        devices: Device[];
        facebookId: string;
        twitterId: string;
        googleId: string;
        gameCenterId: string;
        steamId: string;
        friendIds: string[];
        blockedUserIds: string[];
        createdAt: Date;
        updatedAt: Date;
    }
    export class Auth implements IUser {
        _id: string;
        username: string;
        displayName: string;
        avatarUrl: string;
        isAnonymous: boolean;
        email: string;
        lang: string;
        location: string;
        timezone: string;
        metadata: any;
        devices: Device[];
        facebookId: string;
        twitterId: string;
        googleId: string;
        gameCenterId: string;
        steamId: string;
        friendIds: string[];
        blockedUserIds: string[];
        createdAt: Date;
        updatedAt: Date;
        token: string;
        protected endpoint: string;
        protected keepOnlineInterval: any;
        constructor(endpoint: string);
        readonly hasToken: boolean;
        login(options?: {
            accessToken?: string;
            deviceId?: string;
            platform?: string;
            email?: string;
            password?: string;
        }): Promise<this>;
        save(): Promise<this>;
        getFriends(): Promise<IUser[]>;
        getOnlineFriends(): Promise<IUser[]>;
        getFriendRequests(friendId: string): Promise<IUser[]>;
        sendFriendRequest(friendId: string): Promise<IStatus>;
        acceptFriendRequest(friendId: string): Promise<IStatus>;
        declineFriendRequest(friendId: string): Promise<IStatus>;
        blockUser(friendId: string): Promise<IStatus>;
        unblockUser(friendId: string): Promise<IStatus>;
        logout(): void;
        registerPingService(timeout?: number): void;
        unregisterPingService(): void;
    }
}

declare module 'Colyseus/serializer/FossilDeltaSerializer' {
    import { Serializer } from "Colyseus/serializer/Serializer";
    import { StateContainer } from '@gamestdio/state-listener';
    export class FossilDeltaSerializer<State = any> implements Serializer<State> {
        api: StateContainer<State>;
        protected previousState: any;
        getState(): State;
        setState(encodedState: any): void;
        patch(binaryPatch: any): void;
        teardown(): void;
    }
}

declare module 'Colyseus/serializer/SchemaSerializer' {
    import { Serializer } from "Colyseus/serializer/Serializer";
    import { Schema } from "@colyseus/schema";
    export type RootSchemaConstructor = new (...args: any[]) => Schema;
    export class SchemaSerializer<T extends Schema = any> implements Serializer<T> {
        state: T;
        setState(rawState: any): void;
        getState(): T;
        patch(patches: any): void;
        teardown(): void;
        handshake(bytes: number[]): void;
    }
}

declare module 'Colyseus/serializer/Serializer' {
    export interface Serializer<State> {
        setState(data: any): void;
        getState(): State;
        patch(data: any): void;
        teardown(): void;
        handshake?(bytes: number[]): void;
    }
    export function registerSerializer(id: string, serializer: any): void;
    export function getSerializer(id: string): any;
}

declare module 'Colyseus/Push' {
    export class Push {
        endpoint: string;
        constructor(endpoint: string);
        register(): Promise<void>;
        protected registerServiceWorker(): Promise<ServiceWorkerRegistration>;
        protected requestNotificationPermission(): Promise<void>;
        protected check(): void;
    }
}

declare module 'Colyseus/Connection' {
    import WebSocketClient from '@gamestdio/websocket';
    export class Connection extends WebSocketClient {
        constructor(url: string, autoConnect?: boolean);
        onOpenCallback(event: any): void;
        send(data: any): void;
    }
}

